{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport ApexCharts from \"./apexcharts\";\nwindow.ApexCharts = ApexCharts;\n\nclass Charts extends React.Component {\n  constructor(props) {\n    super(props);\n\n    if (React.createRef) {\n      this.chartRef = /*#__PURE__*/React.createRef();\n    } else {\n      this.setRef = el => this.chartRef = el;\n    }\n\n    this.chart = null;\n  }\n\n  render() {\n    const props = Object.assign({}, this.props);\n    return /*#__PURE__*/React.createElement(\"div\", _objectSpread({\n      ref: React.createRef ? this.chartRef : this.setRef\n    }, props));\n  }\n\n  componentDidMount() {\n    const current = React.createRef ? this.chartRef.current : this.chartRef;\n    this.chart = new ApexCharts(current, this.getConfig());\n    this.chart.render();\n  }\n\n  getConfig() {\n    const {\n      type,\n      height,\n      width,\n      series,\n      options\n    } = this.props;\n    const newOptions = {\n      chart: {\n        type,\n        height,\n        width\n      },\n      series\n    };\n    return this.extend(options, newOptions);\n  }\n\n  isObject(item) {\n    return item && typeof item === \"object\" && !Array.isArray(item) && item != null;\n  }\n\n  extend(target, source) {\n    if (typeof Object.assign !== \"function\") {\n      ;\n\n      (function () {\n        Object.assign = function (target) {\n          // We must check against these specific cases.\n          if (target === undefined || target === null) {\n            throw new TypeError(\"Cannot convert undefined or null to object\");\n          }\n\n          let output = Object(target);\n\n          for (let index = 1; index < arguments.length; index++) {\n            let source = arguments[index];\n\n            if (source !== undefined && source !== null) {\n              for (let nextKey in source) {\n                if (source.hasOwnProperty(nextKey)) {\n                  output[nextKey] = source[nextKey];\n                }\n              }\n            }\n          }\n\n          return output;\n        };\n      })();\n    }\n\n    let output = Object.assign({}, target);\n\n    if (this.isObject(target) && this.isObject(source)) {\n      Object.keys(source).forEach(key => {\n        if (this.isObject(source[key])) {\n          if (!(key in target)) {\n            Object.assign(output, {\n              [key]: source[key]\n            });\n          } else {\n            output[key] = this.extend(target[key], source[key]);\n          }\n        } else {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        }\n      });\n    }\n\n    return output;\n  }\n\n  componentDidUpdate(prevProps) {\n    console.log(this.chart);\n\n    if (prevProps !== this.props) {\n      this.chart.updateOptions(this.getConfig());\n      this.chart.updateSeries(this.props.series);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.chart && typeof this.chart.destroy === \"function\") this.chart.destroy();\n  }\n\n}\n\nCharts.propTypes = {\n  type: PropTypes.string.isRequired,\n  width: PropTypes.any,\n  height: PropTypes.any,\n  series: PropTypes.array.isRequired,\n  options: PropTypes.object.isRequired\n};\nCharts.defaultProps = {\n  type: \"line\",\n  width: \"100%\",\n  height: \"auto\"\n};\nexport default Charts;","map":{"version":3,"sources":["C:/Users/Eloy/Desktop/template/src/modules/apexcharts/react-apexcharts.jsx"],"names":["React","PropTypes","ApexCharts","window","Charts","Component","constructor","props","createRef","chartRef","setRef","el","chart","render","createElement","ref","componentDidMount","current","getConfig","type","height","width","series","options","newOptions","extend","isObject","item","Array","isArray","target","source","Object","assign","undefined","TypeError","output","index","arguments","length","nextKey","hasOwnProperty","keys","forEach","key","componentDidUpdate","prevProps","console","log","updateOptions","updateSeries","componentWillUnmount","destroy","propTypes","string","isRequired","any","array","object","defaultProps"],"mappings":"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","sourcesContent":["import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport ApexCharts from \"./apexcharts\"\n\nwindow.ApexCharts = ApexCharts\n\nclass Charts extends React.Component {\n  constructor(props) {\n    super(props)\n\n    if (React.createRef) {\n      this.chartRef = React.createRef()\n    } else {\n      this.setRef = el => (this.chartRef = el)\n    }\n    this.chart = null\n  }\n\n  render() {\n    const { ...props } = this.props\n    return React.createElement(\"div\", {\n      ref: React.createRef ? this.chartRef : this.setRef,\n      ...props\n    })\n  }\n\n  componentDidMount() {\n    const current = React.createRef ? this.chartRef.current : this.chartRef\n    this.chart = new ApexCharts(current, this.getConfig())\n    this.chart.render()\n  }\n\n  getConfig() {\n    const { type, height, width, series, options } = this.props\n    const newOptions = {\n      chart: {\n        type,\n        height,\n        width\n      },\n      series\n    }\n\n    return this.extend(options, newOptions)\n  }\n\n  isObject(item) {\n    return item && typeof item === \"object\" && !Array.isArray(item) && item != null\n  }\n\n  extend(target, source) {\n    if (typeof Object.assign !== \"function\") {\n      ;(function() {\n        Object.assign = function(target) {\n          // We must check against these specific cases.\n          if (target === undefined || target === null) {\n            throw new TypeError(\"Cannot convert undefined or null to object\")\n          }\n\n          let output = Object(target)\n          for (let index = 1; index < arguments.length; index++) {\n            let source = arguments[index]\n            if (source !== undefined && source !== null) {\n              for (let nextKey in source) {\n                if (source.hasOwnProperty(nextKey)) {\n                  output[nextKey] = source[nextKey]\n                }\n              }\n            }\n          }\n          return output\n        }\n      })()\n    }\n\n    let output = Object.assign({}, target)\n    if (this.isObject(target) && this.isObject(source)) {\n      Object.keys(source).forEach(key => {\n        if (this.isObject(source[key])) {\n          if (!(key in target)) {\n            Object.assign(output, {\n              [key]: source[key]\n            })\n          } else {\n            output[key] = this.extend(target[key], source[key])\n          }\n        } else {\n          Object.assign(output, {\n            [key]: source[key]\n          })\n        }\n      })\n    }\n    return output\n  }\n\n  componentDidUpdate(prevProps) {\n    console.log(this.chart);\n    if (prevProps !== this.props) {\n      this.chart.updateOptions(this.getConfig())\n      this.chart.updateSeries(this.props.series)\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.chart && typeof this.chart.destroy === \"function\") this.chart.destroy()\n  }\n}\n\nCharts.propTypes = {\n  type: PropTypes.string.isRequired,\n  width: PropTypes.any,\n  height: PropTypes.any,\n  series: PropTypes.array.isRequired,\n  options: PropTypes.object.isRequired\n}\n\nCharts.defaultProps = {\n  type: \"line\",\n  width: \"100%\",\n  height: \"auto\"\n}\n\nexport default Charts\n"]},"metadata":{},"sourceType":"module"}