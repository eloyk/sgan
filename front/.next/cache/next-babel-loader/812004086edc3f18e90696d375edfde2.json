{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from \"react\";\nexport function clamp(number, lowerBound, upperBound) {\n  return Math.max(lowerBound, Math.min(number, upperBound));\n}\nexport var getOnDemandLazySlides = function getOnDemandLazySlides(spec) {\n  var onDemandSlides = [];\n  var startIndex = lazyStartIndex(spec);\n  var endIndex = lazyEndIndex(spec);\n\n  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n      onDemandSlides.push(slideIndex);\n    }\n  }\n\n  return onDemandSlides;\n}; // return list of slides that need to be present\n\nexport var getRequiredLazySlides = function getRequiredLazySlides(spec) {\n  var requiredSlides = [];\n  var startIndex = lazyStartIndex(spec);\n  var endIndex = lazyEndIndex(spec);\n\n  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    requiredSlides.push(slideIndex);\n  }\n\n  return requiredSlides;\n}; // startIndex that needs to be present\n\nexport var lazyStartIndex = function lazyStartIndex(spec) {\n  return spec.currentSlide - lazySlidesOnLeft(spec);\n};\nexport var lazyEndIndex = function lazyEndIndex(spec) {\n  return spec.currentSlide + lazySlidesOnRight(spec);\n};\nexport var lazySlidesOnLeft = function lazySlidesOnLeft(spec) {\n  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\n};\nexport var lazySlidesOnRight = function lazySlidesOnRight(spec) {\n  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;\n}; // get width of an element\n\nexport var getWidth = function getWidth(elem) {\n  return elem && elem.offsetWidth || 0;\n};\nexport var getHeight = function getHeight(elem) {\n  return elem && elem.offsetHeight || 0;\n};\nexport var getSwipeDirection = function getSwipeDirection(touchObject) {\n  var verticalSwiping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var xDist, yDist, r, swipeAngle;\n  xDist = touchObject.startX - touchObject.curX;\n  yDist = touchObject.startY - touchObject.curY;\n  r = Math.atan2(yDist, xDist);\n  swipeAngle = Math.round(r * 180 / Math.PI);\n\n  if (swipeAngle < 0) {\n    swipeAngle = 360 - Math.abs(swipeAngle);\n  }\n\n  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n    return \"left\";\n  }\n\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\n    return \"right\";\n  }\n\n  if (verticalSwiping === true) {\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\n      return \"up\";\n    } else {\n      return \"down\";\n    }\n  }\n\n  return \"vertical\";\n}; // whether or not we can go next\n\nexport var canGoNext = function canGoNext(spec) {\n  var canGo = true;\n\n  if (!spec.infinite) {\n    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n      canGo = false;\n    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n      canGo = false;\n    }\n  }\n\n  return canGo;\n}; // given an object and a list of keys, return new object with given keys\n\nexport var extractObject = function extractObject(spec, keys) {\n  var newObject = {};\n  keys.forEach(function (key) {\n    return newObject[key] = spec[key];\n  });\n  return newObject;\n}; // get initialized state\n\nexport var initializedState = function initializedState(spec) {\n  // spec also contains listRef, trackRef\n  var slideCount = React.Children.count(spec.children);\n  var listNode = spec.listRef;\n  var listWidth = Math.ceil(getWidth(listNode));\n  var trackNode = spec.trackRef && spec.trackRef.node;\n  var trackWidth = Math.ceil(getWidth(trackNode));\n  var slideWidth;\n\n  if (!spec.vertical) {\n    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n\n    if (typeof spec.centerPadding === \"string\" && spec.centerPadding.slice(-1) === \"%\") {\n      centerPaddingAdj *= listWidth / 100;\n    }\n\n    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n  } else {\n    slideWidth = listWidth;\n  }\n\n  var slideHeight = listNode && getHeight(listNode.querySelector('[data-index=\"0\"]'));\n  var listHeight = slideHeight * spec.slidesToShow;\n  var currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;\n\n  if (spec.rtl && spec.currentSlide === undefined) {\n    currentSlide = slideCount - 1 - spec.initialSlide;\n  }\n\n  var lazyLoadedList = spec.lazyLoadedList || [];\n  var slidesToLoad = getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n    currentSlide: currentSlide,\n    lazyLoadedList: lazyLoadedList\n  }));\n  lazyLoadedList.concat(slidesToLoad);\n  var state = {\n    slideCount: slideCount,\n    slideWidth: slideWidth,\n    listWidth: listWidth,\n    trackWidth: trackWidth,\n    currentSlide: currentSlide,\n    slideHeight: slideHeight,\n    listHeight: listHeight,\n    lazyLoadedList: lazyLoadedList\n  };\n\n  if (spec.autoplaying === null && spec.autoplay) {\n    state[\"autoplaying\"] = \"playing\";\n  }\n\n  return state;\n};\nexport var slideHandler = function slideHandler(spec) {\n  var waitForAnimate = spec.waitForAnimate,\n      animating = spec.animating,\n      fade = spec.fade,\n      infinite = spec.infinite,\n      index = spec.index,\n      slideCount = spec.slideCount,\n      lazyLoadedList = spec.lazyLoadedList,\n      lazyLoad = spec.lazyLoad,\n      currentSlide = spec.currentSlide,\n      centerMode = spec.centerMode,\n      slidesToScroll = spec.slidesToScroll,\n      slidesToShow = spec.slidesToShow,\n      useCSS = spec.useCSS;\n  if (waitForAnimate && animating) return {};\n  var animationSlide = index,\n      finalSlide,\n      animationLeft,\n      finalLeft;\n  var state = {},\n      nextState = {};\n  var targetSlide = infinite ? index : clamp(index, 0, slideCount - 1);\n\n  if (fade) {\n    if (!infinite && (index < 0 || index >= slideCount)) return {};\n\n    if (index < 0) {\n      animationSlide = index + slideCount;\n    } else if (index >= slideCount) {\n      animationSlide = index - slideCount;\n    }\n\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n      lazyLoadedList.push(animationSlide);\n    }\n\n    state = {\n      animating: true,\n      currentSlide: animationSlide,\n      lazyLoadedList: lazyLoadedList\n    };\n    nextState = {\n      animating: false\n    };\n  } else {\n    finalSlide = animationSlide;\n\n    if (animationSlide < 0) {\n      finalSlide = animationSlide + slideCount;\n      if (!infinite) finalSlide = 0;else if (slideCount % slidesToScroll !== 0) finalSlide = slideCount - slideCount % slidesToScroll;\n    } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n      animationSlide = finalSlide = currentSlide;\n    } else if (centerMode && animationSlide >= slideCount) {\n      animationSlide = infinite ? slideCount : slideCount - 1;\n      finalSlide = infinite ? 0 : slideCount - 1;\n    } else if (animationSlide >= slideCount) {\n      finalSlide = animationSlide - slideCount;\n      if (!infinite) finalSlide = slideCount - slidesToShow;else if (slideCount % slidesToScroll !== 0) finalSlide = 0;\n    }\n\n    if (!infinite && animationSlide + slidesToShow >= slideCount) {\n      finalSlide = slideCount - slidesToShow;\n    }\n\n    animationLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n      slideIndex: animationSlide\n    }));\n    finalLeft = getTrackLeft(_objectSpread(_objectSpread({}, spec), {}, {\n      slideIndex: finalSlide\n    }));\n\n    if (!infinite) {\n      if (animationLeft === finalLeft) animationSlide = finalSlide;\n      animationLeft = finalLeft;\n    }\n\n    lazyLoad && lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread(_objectSpread({}, spec), {}, {\n      currentSlide: animationSlide\n    })));\n\n    if (!useCSS) {\n      state = {\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n          left: finalLeft\n        })),\n        lazyLoadedList: lazyLoadedList,\n        targetSlide: targetSlide\n      };\n    } else {\n      state = {\n        animating: true,\n        currentSlide: finalSlide,\n        trackStyle: getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n          left: animationLeft\n        })),\n        lazyLoadedList: lazyLoadedList,\n        targetSlide: targetSlide\n      };\n      nextState = {\n        animating: false,\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n          left: finalLeft\n        })),\n        swipeLeft: null,\n        targetSlide: targetSlide\n      };\n    }\n  }\n\n  return {\n    state: state,\n    nextState: nextState\n  };\n};\nexport var changeSlide = function changeSlide(spec, options) {\n  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;\n  var slidesToScroll = spec.slidesToScroll,\n      slidesToShow = spec.slidesToShow,\n      slideCount = spec.slideCount,\n      currentSlide = spec.currentSlide,\n      previousTargetSlide = spec.targetSlide,\n      lazyLoad = spec.lazyLoad,\n      infinite = spec.infinite;\n  unevenOffset = slideCount % slidesToScroll !== 0;\n  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n\n  if (options.message === \"previous\") {\n    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n    targetSlide = currentSlide - slideOffset;\n\n    if (lazyLoad && !infinite) {\n      previousInt = currentSlide - slideOffset;\n      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n    }\n\n    if (!infinite) {\n      targetSlide = previousTargetSlide - slidesToScroll;\n    }\n  } else if (options.message === \"next\") {\n    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n    targetSlide = currentSlide + slideOffset;\n\n    if (lazyLoad && !infinite) {\n      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n    }\n\n    if (!infinite) {\n      targetSlide = previousTargetSlide + slidesToScroll;\n    }\n  } else if (options.message === \"dots\") {\n    // Click on dots\n    targetSlide = options.index * options.slidesToScroll;\n  } else if (options.message === \"children\") {\n    // Click on the slides\n    targetSlide = options.index;\n\n    if (infinite) {\n      var direction = siblingDirection(_objectSpread(_objectSpread({}, spec), {}, {\n        targetSlide: targetSlide\n      }));\n\n      if (targetSlide > options.currentSlide && direction === \"left\") {\n        targetSlide = targetSlide - slideCount;\n      } else if (targetSlide < options.currentSlide && direction === \"right\") {\n        targetSlide = targetSlide + slideCount;\n      }\n    }\n  } else if (options.message === \"index\") {\n    targetSlide = Number(options.index);\n  }\n\n  return targetSlide;\n};\nexport var keyHandler = function keyHandler(e, accessibility, rtl) {\n  if (e.target.tagName.match(\"TEXTAREA|INPUT|SELECT\") || !accessibility) return \"\";\n  if (e.keyCode === 37) return rtl ? \"next\" : \"previous\";\n  if (e.keyCode === 39) return rtl ? \"previous\" : \"next\";\n  return \"\";\n};\nexport var swipeStart = function swipeStart(e, swipe, draggable) {\n  e.target.tagName === \"IMG\" && e.preventDefault();\n  if (!swipe || !draggable && e.type.indexOf(\"mouse\") !== -1) return \"\";\n  return {\n    dragging: true,\n    touchObject: {\n      startX: e.touches ? e.touches[0].pageX : e.clientX,\n      startY: e.touches ? e.touches[0].pageY : e.clientY,\n      curX: e.touches ? e.touches[0].pageX : e.clientX,\n      curY: e.touches ? e.touches[0].pageY : e.clientY\n    }\n  };\n};\nexport var swipeMove = function swipeMove(e, spec) {\n  // spec also contains, trackRef and slideIndex\n  var scrolling = spec.scrolling,\n      animating = spec.animating,\n      vertical = spec.vertical,\n      swipeToSlide = spec.swipeToSlide,\n      verticalSwiping = spec.verticalSwiping,\n      rtl = spec.rtl,\n      currentSlide = spec.currentSlide,\n      edgeFriction = spec.edgeFriction,\n      edgeDragged = spec.edgeDragged,\n      onEdge = spec.onEdge,\n      swiped = spec.swiped,\n      swiping = spec.swiping,\n      slideCount = spec.slideCount,\n      slidesToScroll = spec.slidesToScroll,\n      infinite = spec.infinite,\n      touchObject = spec.touchObject,\n      swipeEvent = spec.swipeEvent,\n      listHeight = spec.listHeight,\n      listWidth = spec.listWidth;\n  if (scrolling) return;\n  if (animating) return e.preventDefault();\n  if (vertical && swipeToSlide && verticalSwiping) e.preventDefault();\n  var swipeLeft,\n      state = {};\n  var curLeft = getTrackLeft(spec);\n  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n    return {\n      scrolling: true\n    };\n  }\n\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;\n  var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n  if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n  var dotCount = Math.ceil(slideCount / slidesToScroll);\n  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n  var touchSwipeLength = touchObject.swipeLength;\n\n  if (!infinite) {\n    if (currentSlide === 0 && swipeDirection === \"right\" || currentSlide + 1 >= dotCount && swipeDirection === \"left\" || !canGoNext(spec) && swipeDirection === \"left\") {\n      touchSwipeLength = touchObject.swipeLength * edgeFriction;\n\n      if (edgeDragged === false && onEdge) {\n        onEdge(swipeDirection);\n        state[\"edgeDragged\"] = true;\n      }\n    }\n  }\n\n  if (!swiped && swipeEvent) {\n    swipeEvent(swipeDirection);\n    state[\"swiped\"] = true;\n  }\n\n  if (!vertical) {\n    if (!rtl) {\n      swipeLeft = curLeft + touchSwipeLength * positionOffset;\n    } else {\n      swipeLeft = curLeft - touchSwipeLength * positionOffset;\n    }\n  } else {\n    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n  }\n\n  if (verticalSwiping) {\n    swipeLeft = curLeft + touchSwipeLength * positionOffset;\n  }\n\n  state = _objectSpread(_objectSpread({}, state), {}, {\n    touchObject: touchObject,\n    swipeLeft: swipeLeft,\n    trackStyle: getTrackCSS(_objectSpread(_objectSpread({}, spec), {}, {\n      left: swipeLeft\n    }))\n  });\n\n  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n    return state;\n  }\n\n  if (touchObject.swipeLength > 10) {\n    state[\"swiping\"] = true;\n    e.preventDefault();\n  }\n\n  return state;\n};\nexport var swipeEnd = function swipeEnd(e, spec) {\n  var dragging = spec.dragging,\n      swipe = spec.swipe,\n      touchObject = spec.touchObject,\n      listWidth = spec.listWidth,\n      touchThreshold = spec.touchThreshold,\n      verticalSwiping = spec.verticalSwiping,\n      listHeight = spec.listHeight,\n      swipeToSlide = spec.swipeToSlide,\n      scrolling = spec.scrolling,\n      onSwipe = spec.onSwipe,\n      targetSlide = spec.targetSlide,\n      currentSlide = spec.currentSlide,\n      infinite = spec.infinite;\n\n  if (!dragging) {\n    if (swipe) e.preventDefault();\n    return {};\n  }\n\n  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping); // reset the state of touch related state variables.\n\n  var state = {\n    dragging: false,\n    edgeDragged: false,\n    scrolling: false,\n    swiping: false,\n    swiped: false,\n    swipeLeft: null,\n    touchObject: {}\n  };\n\n  if (scrolling) {\n    return state;\n  }\n\n  if (!touchObject.swipeLength) {\n    return state;\n  }\n\n  if (touchObject.swipeLength > minSwipe) {\n    e.preventDefault();\n\n    if (onSwipe) {\n      onSwipe(swipeDirection);\n    }\n\n    var slideCount, newSlide;\n    var activeSlide = infinite ? currentSlide : targetSlide;\n\n    switch (swipeDirection) {\n      case \"left\":\n      case \"up\":\n        newSlide = activeSlide + getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state[\"currentDirection\"] = 0;\n        break;\n\n      case \"right\":\n      case \"down\":\n        newSlide = activeSlide - getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state[\"currentDirection\"] = 1;\n        break;\n\n      default:\n        slideCount = activeSlide;\n    }\n\n    state[\"triggerSlideHandler\"] = slideCount;\n  } else {\n    // Adjust the track back to it's original position.\n    var currentLeft = getTrackLeft(spec);\n    state[\"trackStyle\"] = getTrackAnimateCSS(_objectSpread(_objectSpread({}, spec), {}, {\n      left: currentLeft\n    }));\n  }\n\n  return state;\n};\nexport var getNavigableIndexes = function getNavigableIndexes(spec) {\n  var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n  var counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n  var indexes = [];\n\n  while (breakpoint < max) {\n    indexes.push(breakpoint);\n    breakpoint = counter + spec.slidesToScroll;\n    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n  }\n\n  return indexes;\n};\nexport var checkNavigable = function checkNavigable(spec, index) {\n  var navigables = getNavigableIndexes(spec);\n  var prevNavigable = 0;\n\n  if (index > navigables[navigables.length - 1]) {\n    index = navigables[navigables.length - 1];\n  } else {\n    for (var n in navigables) {\n      if (index < navigables[n]) {\n        index = prevNavigable;\n        break;\n      }\n\n      prevNavigable = navigables[n];\n    }\n  }\n\n  return index;\n};\nexport var getSlideCount = function getSlideCount(spec) {\n  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n\n  if (spec.swipeToSlide) {\n    var swipedSlide;\n    var slickList = spec.listRef;\n    var slides = slickList.querySelectorAll(\".slick-slide\");\n    Array.from(slides).every(function (slide) {\n      if (!spec.vertical) {\n        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      } else {\n        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    if (!swipedSlide) {\n      return 0;\n    }\n\n    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n    return slidesTraversed;\n  } else {\n    return spec.slidesToScroll;\n  }\n};\nexport var checkSpecKeys = function checkSpecKeys(spec, keysArray) {\n  return keysArray.reduce(function (value, key) {\n    return value && spec.hasOwnProperty(key);\n  }, true) ? null : console.error(\"Keys Missing:\", spec);\n};\nexport var getTrackCSS = function getTrackCSS(spec) {\n  checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\"]);\n  var trackWidth, trackHeight;\n  var trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n\n  if (!spec.vertical) {\n    trackWidth = getTotalSlides(spec) * spec.slideWidth;\n  } else {\n    trackHeight = trackChildren * spec.slideHeight;\n  }\n\n  var style = {\n    opacity: 1,\n    transition: \"\",\n    WebkitTransition: \"\"\n  };\n\n  if (spec.useTransform) {\n    var WebkitTransform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n    var transform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n    var msTransform = !spec.vertical ? \"translateX(\" + spec.left + \"px)\" : \"translateY(\" + spec.left + \"px)\";\n    style = _objectSpread(_objectSpread({}, style), {}, {\n      WebkitTransform: WebkitTransform,\n      transform: transform,\n      msTransform: msTransform\n    });\n  } else {\n    if (spec.vertical) {\n      style[\"top\"] = spec.left;\n    } else {\n      style[\"left\"] = spec.left;\n    }\n  }\n\n  if (spec.fade) style = {\n    opacity: 1\n  };\n  if (trackWidth) style.width = trackWidth;\n  if (trackHeight) style.height = trackHeight; // Fallback for IE8\n\n  if (window && !window.addEventListener && window.attachEvent) {\n    if (!spec.vertical) {\n      style.marginLeft = spec.left + \"px\";\n    } else {\n      style.marginTop = spec.left + \"px\";\n    }\n  }\n\n  return style;\n};\nexport var getTrackAnimateCSS = function getTrackAnimateCSS(spec) {\n  checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\", \"speed\", \"cssEase\"]);\n  var style = getTrackCSS(spec); // useCSS is true by default so it can be undefined\n\n  if (spec.useTransform) {\n    style.WebkitTransition = \"-webkit-transform \" + spec.speed + \"ms \" + spec.cssEase;\n    style.transition = \"transform \" + spec.speed + \"ms \" + spec.cssEase;\n  } else {\n    if (spec.vertical) {\n      style.transition = \"top \" + spec.speed + \"ms \" + spec.cssEase;\n    } else {\n      style.transition = \"left \" + spec.speed + \"ms \" + spec.cssEase;\n    }\n  }\n\n  return style;\n};\nexport var getTrackLeft = function getTrackLeft(spec) {\n  if (spec.unslick) {\n    return 0;\n  }\n\n  checkSpecKeys(spec, [\"slideIndex\", \"trackRef\", \"infinite\", \"centerMode\", \"slideCount\", \"slidesToShow\", \"slidesToScroll\", \"slideWidth\", \"listWidth\", \"variableWidth\", \"slideHeight\"]);\n  var slideIndex = spec.slideIndex,\n      trackRef = spec.trackRef,\n      infinite = spec.infinite,\n      centerMode = spec.centerMode,\n      slideCount = spec.slideCount,\n      slidesToShow = spec.slidesToShow,\n      slidesToScroll = spec.slidesToScroll,\n      slideWidth = spec.slideWidth,\n      listWidth = spec.listWidth,\n      variableWidth = spec.variableWidth,\n      slideHeight = spec.slideHeight,\n      fade = spec.fade,\n      vertical = spec.vertical;\n  var slideOffset = 0;\n  var targetLeft;\n  var targetSlide;\n  var verticalOffset = 0;\n\n  if (fade || spec.slideCount === 1) {\n    return 0;\n  }\n\n  var slidesToOffset = 0;\n\n  if (infinite) {\n    slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n    } // shift current slide to center of the frame\n\n\n    if (centerMode) {\n      slidesToOffset += parseInt(slidesToShow / 2);\n    }\n  } else {\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n    }\n\n    if (centerMode) {\n      slidesToOffset = parseInt(slidesToShow / 2);\n    }\n  }\n\n  slideOffset = slidesToOffset * slideWidth;\n  verticalOffset = slidesToOffset * slideHeight;\n\n  if (!vertical) {\n    targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n  } else {\n    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n  }\n\n  if (variableWidth === true) {\n    var targetSlideIndex;\n    var trackElem = trackRef && trackRef.node;\n    targetSlideIndex = slideIndex + getPreClones(spec);\n    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n\n    if (centerMode === true) {\n      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n      targetSlide = trackElem && trackElem.children[targetSlideIndex];\n      targetLeft = 0;\n\n      for (var slide = 0; slide < targetSlideIndex; slide++) {\n        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n      }\n\n      targetLeft -= parseInt(spec.centerPadding);\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n    }\n  }\n\n  return targetLeft;\n};\nexport var getPreClones = function getPreClones(spec) {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n\n  if (spec.variableWidth) {\n    return spec.slideCount;\n  }\n\n  return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n};\nexport var getPostClones = function getPostClones(spec) {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n\n  return spec.slideCount;\n};\nexport var getTotalSlides = function getTotalSlides(spec) {\n  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\n};\nexport var siblingDirection = function siblingDirection(spec) {\n  if (spec.targetSlide > spec.currentSlide) {\n    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n      return \"left\";\n    }\n\n    return \"right\";\n  } else {\n    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n      return \"right\";\n    }\n\n    return \"left\";\n  }\n};\nexport var slidesOnRight = function slidesOnRight(_ref) {\n  var slidesToShow = _ref.slidesToShow,\n      centerMode = _ref.centerMode,\n      rtl = _ref.rtl,\n      centerPadding = _ref.centerPadding;\n\n  // returns no of slides on the right of active slide\n  if (centerMode) {\n    var right = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) right += 1;\n    if (rtl && slidesToShow % 2 === 0) right += 1;\n    return right;\n  }\n\n  if (rtl) {\n    return 0;\n  }\n\n  return slidesToShow - 1;\n};\nexport var slidesOnLeft = function slidesOnLeft(_ref2) {\n  var slidesToShow = _ref2.slidesToShow,\n      centerMode = _ref2.centerMode,\n      rtl = _ref2.rtl,\n      centerPadding = _ref2.centerPadding;\n\n  // returns no of slides on the left of active slide\n  if (centerMode) {\n    var left = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) left += 1;\n    if (!rtl && slidesToShow % 2 === 0) left += 1;\n    return left;\n  }\n\n  if (rtl) {\n    return slidesToShow - 1;\n  }\n\n  return 0;\n};\nexport var canUseDOM = function canUseDOM() {\n  return !!(true && window.document && window.document.createElement);\n};","map":{"version":3,"sources":["C:/Users/Eloy/Desktop/template/src/modules/slick/utils/innerSliderUtils.jsx"],"names":["React","clamp","number","lowerBound","upperBound","Math","max","min","getOnDemandLazySlides","spec","onDemandSlides","startIndex","lazyStartIndex","endIndex","lazyEndIndex","slideIndex","lazyLoadedList","indexOf","push","getRequiredLazySlides","requiredSlides","currentSlide","lazySlidesOnLeft","lazySlidesOnRight","centerMode","floor","slidesToShow","parseInt","centerPadding","getWidth","elem","offsetWidth","getHeight","offsetHeight","getSwipeDirection","touchObject","verticalSwiping","xDist","yDist","r","swipeAngle","startX","curX","startY","curY","atan2","round","PI","abs","canGoNext","canGo","infinite","slideCount","extractObject","keys","newObject","forEach","key","initializedState","Children","count","children","listNode","listRef","listWidth","ceil","trackNode","trackRef","node","trackWidth","slideWidth","vertical","centerPaddingAdj","slice","slideHeight","querySelector","listHeight","undefined","initialSlide","rtl","slidesToLoad","concat","state","autoplaying","autoplay","slideHandler","waitForAnimate","animating","fade","index","lazyLoad","slidesToScroll","useCSS","animationSlide","finalSlide","animationLeft","finalLeft","nextState","targetSlide","getTrackLeft","trackStyle","getTrackCSS","left","getTrackAnimateCSS","swipeLeft","changeSlide","options","indexOffset","previousInt","slideOffset","unevenOffset","previousTargetSlide","message","direction","siblingDirection","Number","keyHandler","e","accessibility","target","tagName","match","keyCode","swipeStart","swipe","draggable","preventDefault","type","dragging","touches","pageX","clientX","pageY","clientY","swipeMove","scrolling","swipeToSlide","edgeFriction","edgeDragged","onEdge","swiped","swiping","swipeEvent","curLeft","swipeLength","sqrt","pow","verticalSwipeLength","positionOffset","dotCount","swipeDirection","touchSwipeLength","swipeEnd","touchThreshold","onSwipe","minSwipe","newSlide","activeSlide","getSlideCount","checkNavigable","currentLeft","getNavigableIndexes","breakpoint","counter","indexes","navigables","prevNavigable","length","n","centerOffset","swipedSlide","slickList","slides","querySelectorAll","Array","from","every","slide","offsetLeft","offsetTop","currentIndex","slidesTraversed","dataset","checkSpecKeys","keysArray","reduce","value","hasOwnProperty","console","error","trackHeight","trackChildren","getTotalSlides","style","opacity","transition","WebkitTransition","useTransform","WebkitTransform","transform","msTransform","width","height","window","addEventListener","attachEvent","marginLeft","marginTop","speed","cssEase","unslick","variableWidth","targetLeft","verticalOffset","slidesToOffset","getPreClones","targetSlideIndex","trackElem","childNodes","getPostClones","slidesOnRight","slidesOnLeft","right","canUseDOM","document","createElement"],"mappings":"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","sourcesContent":["import React from \"react\"\n\nexport function clamp(number, lowerBound, upperBound) {\n  return Math.max(lowerBound, Math.min(number, upperBound))\n}\n\nexport const getOnDemandLazySlides = spec => {\n  let onDemandSlides = []\n  let startIndex = lazyStartIndex(spec)\n  let endIndex = lazyEndIndex(spec)\n  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n      onDemandSlides.push(slideIndex)\n    }\n  }\n  return onDemandSlides\n}\n\n// return list of slides that need to be present\nexport const getRequiredLazySlides = spec => {\n  let requiredSlides = []\n  let startIndex = lazyStartIndex(spec)\n  let endIndex = lazyEndIndex(spec)\n  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    requiredSlides.push(slideIndex)\n  }\n  return requiredSlides\n}\n\n// startIndex that needs to be present\nexport const lazyStartIndex = spec => spec.currentSlide - lazySlidesOnLeft(spec)\nexport const lazyEndIndex = spec => spec.currentSlide + lazySlidesOnRight(spec)\nexport const lazySlidesOnLeft = spec =>\n  spec.centerMode\n    ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0)\n    : 0\nexport const lazySlidesOnRight = spec =>\n  spec.centerMode\n    ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0)\n    : spec.slidesToShow\n\n// get width of an element\nexport const getWidth = elem => (elem && elem.offsetWidth) || 0\nexport const getHeight = elem => (elem && elem.offsetHeight) || 0\nexport const getSwipeDirection = (touchObject, verticalSwiping = false) => {\n  var xDist, yDist, r, swipeAngle\n  xDist = touchObject.startX - touchObject.curX\n  yDist = touchObject.startY - touchObject.curY\n  r = Math.atan2(yDist, xDist)\n  swipeAngle = Math.round((r * 180) / Math.PI)\n  if (swipeAngle < 0) {\n    swipeAngle = 360 - Math.abs(swipeAngle)\n  }\n  if ((swipeAngle <= 45 && swipeAngle >= 0) || (swipeAngle <= 360 && swipeAngle >= 315)) {\n    return \"left\"\n  }\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\n    return \"right\"\n  }\n  if (verticalSwiping === true) {\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\n      return \"up\"\n    } else {\n      return \"down\"\n    }\n  }\n\n  return \"vertical\"\n}\n\n// whether or not we can go next\nexport const canGoNext = spec => {\n  let canGo = true\n  if (!spec.infinite) {\n    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n      canGo = false\n    } else if (\n      spec.slideCount <= spec.slidesToShow ||\n      spec.currentSlide >= spec.slideCount - spec.slidesToShow\n    ) {\n      canGo = false\n    }\n  }\n  return canGo\n}\n\n// given an object and a list of keys, return new object with given keys\nexport const extractObject = (spec, keys) => {\n  let newObject = {}\n  keys.forEach(key => (newObject[key] = spec[key]))\n  return newObject\n}\n\n// get initialized state\nexport const initializedState = spec => {\n  // spec also contains listRef, trackRef\n  let slideCount = React.Children.count(spec.children)\n  const listNode = spec.listRef\n  let listWidth = Math.ceil(getWidth(listNode))\n  const trackNode = spec.trackRef && spec.trackRef.node\n  let trackWidth = Math.ceil(getWidth(trackNode))\n  let slideWidth\n  if (!spec.vertical) {\n    let centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2\n    if (typeof spec.centerPadding === \"string\" && spec.centerPadding.slice(-1) === \"%\") {\n      centerPaddingAdj *= listWidth / 100\n    }\n    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow)\n  } else {\n    slideWidth = listWidth\n  }\n  let slideHeight = listNode && getHeight(listNode.querySelector('[data-index=\"0\"]'))\n  let listHeight = slideHeight * spec.slidesToShow\n  let currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide\n  if (spec.rtl && spec.currentSlide === undefined) {\n    currentSlide = slideCount - 1 - spec.initialSlide\n  }\n  let lazyLoadedList = spec.lazyLoadedList || []\n  let slidesToLoad = getOnDemandLazySlides({\n    ...spec,\n    currentSlide,\n    lazyLoadedList\n  })\n  lazyLoadedList.concat(slidesToLoad)\n\n  let state = {\n    slideCount,\n    slideWidth,\n    listWidth,\n    trackWidth,\n    currentSlide,\n    slideHeight,\n    listHeight,\n    lazyLoadedList\n  }\n\n  if (spec.autoplaying === null && spec.autoplay) {\n    state[\"autoplaying\"] = \"playing\"\n  }\n\n  return state\n}\n\nexport const slideHandler = spec => {\n  const {\n    waitForAnimate,\n    animating,\n    fade,\n    infinite,\n    index,\n    slideCount,\n    lazyLoadedList,\n    lazyLoad,\n    currentSlide,\n    centerMode,\n    slidesToScroll,\n    slidesToShow,\n    useCSS\n  } = spec\n  if (waitForAnimate && animating) return {}\n  let animationSlide = index,\n    finalSlide,\n    animationLeft,\n    finalLeft\n  let state = {},\n    nextState = {}\n  const targetSlide = infinite ? index : clamp(index, 0, slideCount - 1)\n  if (fade) {\n    if (!infinite && (index < 0 || index >= slideCount)) return {}\n    if (index < 0) {\n      animationSlide = index + slideCount\n    } else if (index >= slideCount) {\n      animationSlide = index - slideCount\n    }\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n      lazyLoadedList.push(animationSlide)\n    }\n    state = {\n      animating: true,\n      currentSlide: animationSlide,\n      lazyLoadedList\n    }\n    nextState = { animating: false }\n  } else {\n    finalSlide = animationSlide\n    if (animationSlide < 0) {\n      finalSlide = animationSlide + slideCount\n      if (!infinite) finalSlide = 0\n      else if (slideCount % slidesToScroll !== 0)\n        finalSlide = slideCount - (slideCount % slidesToScroll)\n    } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n      animationSlide = finalSlide = currentSlide\n    } else if (centerMode && animationSlide >= slideCount) {\n      animationSlide = infinite ? slideCount : slideCount - 1\n      finalSlide = infinite ? 0 : slideCount - 1\n    } else if (animationSlide >= slideCount) {\n      finalSlide = animationSlide - slideCount\n      if (!infinite) finalSlide = slideCount - slidesToShow\n      else if (slideCount % slidesToScroll !== 0) finalSlide = 0\n    }\n\n    if (!infinite && animationSlide + slidesToShow >= slideCount) {\n      finalSlide = slideCount - slidesToShow\n    }\n\n    animationLeft = getTrackLeft({ ...spec, slideIndex: animationSlide })\n    finalLeft = getTrackLeft({ ...spec, slideIndex: finalSlide })\n    if (!infinite) {\n      if (animationLeft === finalLeft) animationSlide = finalSlide\n      animationLeft = finalLeft\n    }\n    lazyLoad &&\n      lazyLoadedList.concat(getOnDemandLazySlides({ ...spec, currentSlide: animationSlide }))\n    if (!useCSS) {\n      state = {\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS({ ...spec, left: finalLeft }),\n        lazyLoadedList,\n        targetSlide\n      }\n    } else {\n      state = {\n        animating: true,\n        currentSlide: finalSlide,\n        trackStyle: getTrackAnimateCSS({ ...spec, left: animationLeft }),\n        lazyLoadedList,\n        targetSlide\n      }\n      nextState = {\n        animating: false,\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS({ ...spec, left: finalLeft }),\n        swipeLeft: null,\n        targetSlide\n      }\n    }\n  }\n  return { state, nextState }\n}\n\nexport const changeSlide = (spec, options) => {\n  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide\n  const {\n    slidesToScroll,\n    slidesToShow,\n    slideCount,\n    currentSlide,\n    targetSlide: previousTargetSlide,\n    lazyLoad,\n    infinite\n  } = spec\n  unevenOffset = slideCount % slidesToScroll !== 0\n  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll\n\n  if (options.message === \"previous\") {\n    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset\n    targetSlide = currentSlide - slideOffset\n    if (lazyLoad && !infinite) {\n      previousInt = currentSlide - slideOffset\n      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt\n    }\n    if (!infinite) {\n      targetSlide = previousTargetSlide - slidesToScroll\n    }\n  } else if (options.message === \"next\") {\n    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset\n    targetSlide = currentSlide + slideOffset\n    if (lazyLoad && !infinite) {\n      targetSlide = ((currentSlide + slidesToScroll) % slideCount) + indexOffset\n    }\n    if (!infinite) {\n      targetSlide = previousTargetSlide + slidesToScroll\n    }\n  } else if (options.message === \"dots\") {\n    // Click on dots\n    targetSlide = options.index * options.slidesToScroll\n  } else if (options.message === \"children\") {\n    // Click on the slides\n    targetSlide = options.index\n    if (infinite) {\n      let direction = siblingDirection({ ...spec, targetSlide })\n      if (targetSlide > options.currentSlide && direction === \"left\") {\n        targetSlide = targetSlide - slideCount\n      } else if (targetSlide < options.currentSlide && direction === \"right\") {\n        targetSlide = targetSlide + slideCount\n      }\n    }\n  } else if (options.message === \"index\") {\n    targetSlide = Number(options.index)\n  }\n  return targetSlide\n}\nexport const keyHandler = (e, accessibility, rtl) => {\n  if (e.target.tagName.match(\"TEXTAREA|INPUT|SELECT\") || !accessibility) return \"\"\n  if (e.keyCode === 37) return rtl ? \"next\" : \"previous\"\n  if (e.keyCode === 39) return rtl ? \"previous\" : \"next\"\n  return \"\"\n}\n\nexport const swipeStart = (e, swipe, draggable) => {\n  e.target.tagName === \"IMG\" && e.preventDefault()\n  if (!swipe || (!draggable && e.type.indexOf(\"mouse\") !== -1)) return \"\"\n  return {\n    dragging: true,\n    touchObject: {\n      startX: e.touches ? e.touches[0].pageX : e.clientX,\n      startY: e.touches ? e.touches[0].pageY : e.clientY,\n      curX: e.touches ? e.touches[0].pageX : e.clientX,\n      curY: e.touches ? e.touches[0].pageY : e.clientY\n    }\n  }\n}\nexport const swipeMove = (e, spec) => {\n  // spec also contains, trackRef and slideIndex\n  const {\n    scrolling,\n    animating,\n    vertical,\n    swipeToSlide,\n    verticalSwiping,\n    rtl,\n    currentSlide,\n    edgeFriction,\n    edgeDragged,\n    onEdge,\n    swiped,\n    swiping,\n    slideCount,\n    slidesToScroll,\n    infinite,\n    touchObject,\n    swipeEvent,\n    listHeight,\n    listWidth\n  } = spec\n  if (scrolling) return\n  if (animating) return e.preventDefault()\n  if (vertical && swipeToSlide && verticalSwiping) e.preventDefault()\n  let swipeLeft,\n    state = {}\n  let curLeft = getTrackLeft(spec)\n  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX\n  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY\n  touchObject.swipeLength = Math.round(\n    Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2))\n  )\n  let verticalSwipeLength = Math.round(\n    Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2))\n  )\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n    return { scrolling: true }\n  }\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength\n  let positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1)\n  if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1\n\n  let dotCount = Math.ceil(slideCount / slidesToScroll)\n  let swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping)\n  let touchSwipeLength = touchObject.swipeLength\n  if (!infinite) {\n    if (\n      (currentSlide === 0 && swipeDirection === \"right\") ||\n      (currentSlide + 1 >= dotCount && swipeDirection === \"left\") ||\n      (!canGoNext(spec) && swipeDirection === \"left\")\n    ) {\n      touchSwipeLength = touchObject.swipeLength * edgeFriction\n      if (edgeDragged === false && onEdge) {\n        onEdge(swipeDirection)\n        state[\"edgeDragged\"] = true\n      }\n    }\n  }\n  if (!swiped && swipeEvent) {\n    swipeEvent(swipeDirection)\n    state[\"swiped\"] = true\n  }\n  if (!vertical) {\n    if (!rtl) {\n      swipeLeft = curLeft + touchSwipeLength * positionOffset\n    } else {\n      swipeLeft = curLeft - touchSwipeLength * positionOffset\n    }\n  } else {\n    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset\n  }\n  if (verticalSwiping) {\n    swipeLeft = curLeft + touchSwipeLength * positionOffset\n  }\n  state = {\n    ...state,\n    touchObject,\n    swipeLeft,\n    trackStyle: getTrackCSS({ ...spec, left: swipeLeft })\n  }\n  if (\n    Math.abs(touchObject.curX - touchObject.startX) <\n    Math.abs(touchObject.curY - touchObject.startY) * 0.8\n  ) {\n    return state\n  }\n  if (touchObject.swipeLength > 10) {\n    state[\"swiping\"] = true\n    e.preventDefault()\n  }\n  return state\n}\nexport const swipeEnd = (e, spec) => {\n  const {\n    dragging,\n    swipe,\n    touchObject,\n    listWidth,\n    touchThreshold,\n    verticalSwiping,\n    listHeight,\n    swipeToSlide,\n    scrolling,\n    onSwipe,\n    targetSlide,\n    currentSlide,\n    infinite\n  } = spec\n  if (!dragging) {\n    if (swipe) e.preventDefault()\n    return {}\n  }\n  let minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold\n  let swipeDirection = getSwipeDirection(touchObject, verticalSwiping)\n  // reset the state of touch related state variables.\n  let state = {\n    dragging: false,\n    edgeDragged: false,\n    scrolling: false,\n    swiping: false,\n    swiped: false,\n    swipeLeft: null,\n    touchObject: {}\n  }\n  if (scrolling) {\n    return state\n  }\n  if (!touchObject.swipeLength) {\n    return state\n  }\n  if (touchObject.swipeLength > minSwipe) {\n    e.preventDefault()\n    if (onSwipe) {\n      onSwipe(swipeDirection)\n    }\n    let slideCount, newSlide\n    let activeSlide = infinite ? currentSlide : targetSlide\n    switch (swipeDirection) {\n      case \"left\":\n      case \"up\":\n        newSlide = activeSlide + getSlideCount(spec)\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide\n        state[\"currentDirection\"] = 0\n        break\n      case \"right\":\n      case \"down\":\n        newSlide = activeSlide - getSlideCount(spec)\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide\n        state[\"currentDirection\"] = 1\n        break\n      default:\n        slideCount = activeSlide\n    }\n    state[\"triggerSlideHandler\"] = slideCount\n  } else {\n    // Adjust the track back to it's original position.\n    let currentLeft = getTrackLeft(spec)\n    state[\"trackStyle\"] = getTrackAnimateCSS({ ...spec, left: currentLeft })\n  }\n  return state\n}\nexport const getNavigableIndexes = spec => {\n  let max = spec.infinite ? spec.slideCount * 2 : spec.slideCount\n  let breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0\n  let counter = spec.infinite ? spec.slidesToShow * -1 : 0\n  let indexes = []\n  while (breakpoint < max) {\n    indexes.push(breakpoint)\n    breakpoint = counter + spec.slidesToScroll\n    counter += Math.min(spec.slidesToScroll, spec.slidesToShow)\n  }\n  return indexes\n}\nexport const checkNavigable = (spec, index) => {\n  const navigables = getNavigableIndexes(spec)\n  let prevNavigable = 0\n  if (index > navigables[navigables.length - 1]) {\n    index = navigables[navigables.length - 1]\n  } else {\n    for (let n in navigables) {\n      if (index < navigables[n]) {\n        index = prevNavigable\n        break\n      }\n      prevNavigable = navigables[n]\n    }\n  }\n  return index\n}\nexport const getSlideCount = spec => {\n  const centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0\n  if (spec.swipeToSlide) {\n    let swipedSlide\n    const slickList = spec.listRef\n    const slides = slickList.querySelectorAll(\".slick-slide\")\n    Array.from(slides).every(slide => {\n      if (!spec.vertical) {\n        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide\n          return false\n        }\n      } else {\n        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide\n          return false\n        }\n      }\n\n      return true\n    })\n\n    if (!swipedSlide) {\n      return 0\n    }\n    const currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide\n    const slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1\n    return slidesTraversed\n  } else {\n    return spec.slidesToScroll\n  }\n}\n\nexport const checkSpecKeys = (spec, keysArray) =>\n  keysArray.reduce((value, key) => value && spec.hasOwnProperty(key), true)\n    ? null\n    : console.error(\"Keys Missing:\", spec)\n\nexport const getTrackCSS = spec => {\n  checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\"])\n  let trackWidth, trackHeight\n  const trackChildren = spec.slideCount + 2 * spec.slidesToShow\n  if (!spec.vertical) {\n    trackWidth = getTotalSlides(spec) * spec.slideWidth\n  } else {\n    trackHeight = trackChildren * spec.slideHeight\n  }\n  let style = {\n    opacity: 1,\n    transition: \"\",\n    WebkitTransition: \"\"\n  }\n  if (spec.useTransform) {\n    let WebkitTransform = !spec.vertical\n      ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\"\n      : \"translate3d(0px, \" + spec.left + \"px, 0px)\"\n    let transform = !spec.vertical\n      ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\"\n      : \"translate3d(0px, \" + spec.left + \"px, 0px)\"\n    let msTransform = !spec.vertical\n      ? \"translateX(\" + spec.left + \"px)\"\n      : \"translateY(\" + spec.left + \"px)\"\n    style = {\n      ...style,\n      WebkitTransform,\n      transform,\n      msTransform\n    }\n  } else {\n    if (spec.vertical) {\n      style[\"top\"] = spec.left\n    } else {\n      style[\"left\"] = spec.left\n    }\n  }\n  if (spec.fade) style = { opacity: 1 }\n  if (trackWidth) style.width = trackWidth\n  if (trackHeight) style.height = trackHeight\n\n  // Fallback for IE8\n  if (window && !window.addEventListener && window.attachEvent) {\n    if (!spec.vertical) {\n      style.marginLeft = spec.left + \"px\"\n    } else {\n      style.marginTop = spec.left + \"px\"\n    }\n  }\n\n  return style\n}\nexport const getTrackAnimateCSS = spec => {\n  checkSpecKeys(spec, [\n    \"left\",\n    \"variableWidth\",\n    \"slideCount\",\n    \"slidesToShow\",\n    \"slideWidth\",\n    \"speed\",\n    \"cssEase\"\n  ])\n  let style = getTrackCSS(spec)\n  // useCSS is true by default so it can be undefined\n  if (spec.useTransform) {\n    style.WebkitTransition = \"-webkit-transform \" + spec.speed + \"ms \" + spec.cssEase\n    style.transition = \"transform \" + spec.speed + \"ms \" + spec.cssEase\n  } else {\n    if (spec.vertical) {\n      style.transition = \"top \" + spec.speed + \"ms \" + spec.cssEase\n    } else {\n      style.transition = \"left \" + spec.speed + \"ms \" + spec.cssEase\n    }\n  }\n  return style\n}\nexport const getTrackLeft = spec => {\n  if (spec.unslick) {\n    return 0\n  }\n\n  checkSpecKeys(spec, [\n    \"slideIndex\",\n    \"trackRef\",\n    \"infinite\",\n    \"centerMode\",\n    \"slideCount\",\n    \"slidesToShow\",\n    \"slidesToScroll\",\n    \"slideWidth\",\n    \"listWidth\",\n    \"variableWidth\",\n    \"slideHeight\"\n  ])\n\n  const {\n    slideIndex,\n    trackRef,\n    infinite,\n    centerMode,\n    slideCount,\n    slidesToShow,\n    slidesToScroll,\n    slideWidth,\n    listWidth,\n    variableWidth,\n    slideHeight,\n    fade,\n    vertical\n  } = spec\n\n  var slideOffset = 0\n  var targetLeft\n  var targetSlide\n  var verticalOffset = 0\n\n  if (fade || spec.slideCount === 1) {\n    return 0\n  }\n\n  let slidesToOffset = 0\n  if (infinite) {\n    slidesToOffset = -getPreClones(spec) // bring active slide to the beginning of visual area\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = -(slideIndex > slideCount\n        ? slidesToShow - (slideIndex - slideCount)\n        : slideCount % slidesToScroll)\n    }\n    // shift current slide to center of the frame\n    if (centerMode) {\n      slidesToOffset += parseInt(slidesToShow / 2)\n    }\n  } else {\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = slidesToShow - (slideCount % slidesToScroll)\n    }\n    if (centerMode) {\n      slidesToOffset = parseInt(slidesToShow / 2)\n    }\n  }\n  slideOffset = slidesToOffset * slideWidth\n  verticalOffset = slidesToOffset * slideHeight\n\n  if (!vertical) {\n    targetLeft = slideIndex * slideWidth * -1 + slideOffset\n  } else {\n    targetLeft = slideIndex * slideHeight * -1 + verticalOffset\n  }\n\n  if (variableWidth === true) {\n    var targetSlideIndex\n    const trackElem = trackRef && trackRef.node\n    targetSlideIndex = slideIndex + getPreClones(spec)\n    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex]\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0\n    if (centerMode === true) {\n      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex\n      targetSlide = trackElem && trackElem.children[targetSlideIndex]\n      targetLeft = 0\n      for (let slide = 0; slide < targetSlideIndex; slide++) {\n        targetLeft -=\n          trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth\n      }\n      targetLeft -= parseInt(spec.centerPadding)\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2\n    }\n  }\n\n  return targetLeft\n}\n\nexport const getPreClones = spec => {\n  if (spec.unslick || !spec.infinite) {\n    return 0\n  }\n  if (spec.variableWidth) {\n    return spec.slideCount\n  }\n  return spec.slidesToShow + (spec.centerMode ? 1 : 0)\n}\n\nexport const getPostClones = spec => {\n  if (spec.unslick || !spec.infinite) {\n    return 0\n  }\n  return spec.slideCount\n}\n\nexport const getTotalSlides = spec =>\n  spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec)\nexport const siblingDirection = spec => {\n  if (spec.targetSlide > spec.currentSlide) {\n    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n      return \"left\"\n    }\n    return \"right\"\n  } else {\n    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n      return \"right\"\n    }\n    return \"left\"\n  }\n}\n\nexport const slidesOnRight = ({ slidesToShow, centerMode, rtl, centerPadding }) => {\n  // returns no of slides on the right of active slide\n  if (centerMode) {\n    let right = (slidesToShow - 1) / 2 + 1\n    if (parseInt(centerPadding) > 0) right += 1\n    if (rtl && slidesToShow % 2 === 0) right += 1\n    return right\n  }\n  if (rtl) {\n    return 0\n  }\n  return slidesToShow - 1\n}\n\nexport const slidesOnLeft = ({ slidesToShow, centerMode, rtl, centerPadding }) => {\n  // returns no of slides on the left of active slide\n  if (centerMode) {\n    let left = (slidesToShow - 1) / 2 + 1\n    if (parseInt(centerPadding) > 0) left += 1\n    if (!rtl && slidesToShow % 2 === 0) left += 1\n    return left\n  }\n  if (rtl) {\n    return slidesToShow - 1\n  }\n  return 0\n}\n\nexport const canUseDOM = () =>\n  !!(typeof window !== \"undefined\" && window.document && window.document.createElement)\n"]},"metadata":{},"sourceType":"module"}