{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from \"react\";\nimport { InnerSlider } from \"./inner-slider\";\nimport json2mq from \"json2mq\";\nimport defaultProps from \"./default-props\";\nimport { canUseDOM } from \"./utils/innerSliderUtils\";\n\nconst enquire = canUseDOM() && require(\"enquire.js\");\n\nexport default class Slider extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"innerSliderRefHandler\", ref => this.innerSlider = ref);\n\n    _defineProperty(this, \"slickPrev\", () => this.innerSlider.slickPrev());\n\n    _defineProperty(this, \"slickNext\", () => this.innerSlider.slickNext());\n\n    _defineProperty(this, \"slickGoTo\", (slide, dontAnimate = false) => this.innerSlider.slickGoTo(slide, dontAnimate));\n\n    _defineProperty(this, \"slickPause\", () => this.innerSlider.pause(\"paused\"));\n\n    _defineProperty(this, \"slickPlay\", () => this.innerSlider.autoPlay(\"play\"));\n\n    this.state = {\n      breakpoint: null\n    };\n    this._responsiveMediaHandlers = [];\n  }\n\n  media(query, handler) {\n    // javascript handler for  css media query\n    enquire.register(query, handler);\n\n    this._responsiveMediaHandlers.push({\n      query,\n      handler\n    });\n  } // handles responsive breakpoints\n\n\n  componentDidMount() {\n    // performance monitoring\n    //if (process.env.NODE_ENV !== 'production') {\n    //const { whyDidYouUpdate } = require('why-did-you-update')\n    //whyDidYouUpdate(React)\n    //}\n    if (this.props.responsive) {\n      let breakpoints = this.props.responsive.map(breakpt => breakpt.breakpoint); // sort them in increasing order of their numerical value\n\n      breakpoints.sort((x, y) => x - y);\n      breakpoints.forEach((breakpoint, index) => {\n        // media query for each breakpoint\n        let bQuery;\n\n        if (index === 0) {\n          bQuery = json2mq({\n            minWidth: 0,\n            maxWidth: breakpoint\n          });\n        } else {\n          bQuery = json2mq({\n            minWidth: breakpoints[index - 1] + 1,\n            maxWidth: breakpoint\n          });\n        } // when not using server side rendering\n\n\n        canUseDOM() && this.media(bQuery, () => {\n          this.setState({\n            breakpoint: breakpoint\n          });\n        });\n      }); // Register media query for full screen. Need to support resize from small to large\n      // convert javascript object to media query string\n\n      let query = json2mq({\n        minWidth: breakpoints.slice(-1)[0]\n      });\n      canUseDOM() && this.media(query, () => {\n        this.setState({\n          breakpoint: null\n        });\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this._responsiveMediaHandlers.forEach(function (obj) {\n      enquire.unregister(obj.query, obj.handler);\n    });\n  }\n\n  render() {\n    var settings;\n    var newProps;\n\n    if (this.state.breakpoint) {\n      newProps = this.props.responsive.filter(resp => resp.breakpoint === this.state.breakpoint);\n      settings = newProps[0].settings === \"unslick\" ? \"unslick\" : _objectSpread(_objectSpread(_objectSpread({}, defaultProps), this.props), newProps[0].settings);\n    } else {\n      settings = _objectSpread(_objectSpread({}, defaultProps), this.props);\n    } // force scrolling by one if centerMode is on\n\n\n    if (settings.centerMode) {\n      if (settings.slidesToScroll > 1 && false) {\n        console.warn(`slidesToScroll should be equal to 1 in centerMode, you are using ${settings.slidesToScroll}`);\n      }\n\n      settings.slidesToScroll = 1;\n    } // force showing one slide and scrolling by one if the fade mode is on\n\n\n    if (settings.fade) {\n      if (settings.slidesToShow > 1 && false) {\n        console.warn(`slidesToShow should be equal to 1 when fade is true, you're using ${settings.slidesToShow}`);\n      }\n\n      if (settings.slidesToScroll > 1 && false) {\n        console.warn(`slidesToScroll should be equal to 1 when fade is true, you're using ${settings.slidesToScroll}`);\n      }\n\n      settings.slidesToShow = 1;\n      settings.slidesToScroll = 1;\n    } // makes sure that children is an array, even when there is only 1 child\n\n\n    let children = React.Children.toArray(this.props.children); // Children may contain false or null, so we should filter them\n    // children may also contain string filled with spaces (in certain cases where we use jsx strings)\n\n    children = children.filter(child => {\n      if (typeof child === \"string\") {\n        return !!child.trim();\n      }\n\n      return !!child;\n    }); // rows and slidesPerRow logic is handled here\n\n    if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {\n      console.warn(`variableWidth is not supported in case of rows > 1 or slidesPerRow > 1`);\n      settings.variableWidth = false;\n    }\n\n    let newChildren = [];\n    let currentWidth = null;\n\n    for (let i = 0; i < children.length; i += settings.rows * settings.slidesPerRow) {\n      let newSlide = [];\n\n      for (let j = i; j < i + settings.rows * settings.slidesPerRow; j += settings.slidesPerRow) {\n        let row = [];\n\n        for (let k = j; k < j + settings.slidesPerRow; k += 1) {\n          if (settings.variableWidth && children[k].props.style) {\n            currentWidth = children[k].props.style.width;\n          }\n\n          if (k >= children.length) break;\n          row.push( /*#__PURE__*/React.cloneElement(children[k], {\n            key: 100 * i + 10 * j + k,\n            tabIndex: -1,\n            style: {\n              width: `${100 / settings.slidesPerRow}%`,\n              display: \"inline-block\"\n            }\n          }));\n        }\n\n        newSlide.push(__jsx(\"div\", {\n          key: 10 * i + j\n        }, row));\n      }\n\n      if (settings.variableWidth) {\n        newChildren.push(__jsx(\"div\", {\n          key: i,\n          style: {\n            width: currentWidth\n          }\n        }, newSlide));\n      } else {\n        newChildren.push(__jsx(\"div\", {\n          key: i\n        }, newSlide));\n      }\n    }\n\n    if (settings === \"unslick\") {\n      const className = \"regular slider \" + (this.props.className || \"\");\n      return __jsx(\"div\", {\n        className: className\n      }, children);\n    } else if (newChildren.length <= settings.slidesToShow) {\n      settings.unslick = true;\n    }\n\n    return __jsx(InnerSlider, _extends({\n      style: this.props.style,\n      ref: this.innerSliderRefHandler\n    }, settings), newChildren);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}