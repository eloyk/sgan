{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from \"react\";\nimport initialState from \"./initial-state\";\nimport debounce from \"lodash.debounce\";\nimport classnames from \"classnames\";\nimport { getOnDemandLazySlides, extractObject, initializedState, getHeight, canGoNext, slideHandler, changeSlide, keyHandler, swipeStart, swipeMove, swipeEnd, getPreClones, getPostClones, getTrackLeft, getTrackCSS } from \"./utils/innerSliderUtils\";\nimport { Track } from \"./track\";\nimport { Dots } from \"./dots\";\nimport { PrevArrow, NextArrow } from \"./arrows\";\nimport ResizeObserver from \"resize-observer-polyfill\";\nexport class InnerSlider extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"listRefHandler\", ref => this.list = ref);\n\n    _defineProperty(this, \"trackRefHandler\", ref => this.track = ref);\n\n    _defineProperty(this, \"adaptHeight\", () => {\n      if (this.props.adaptiveHeight && this.list) {\n        const elem = this.list.querySelector(`[data-index=\"${this.state.currentSlide}\"]`);\n        this.list.style.height = getHeight(elem) + \"px\";\n      }\n    });\n\n    _defineProperty(this, \"componentDidMount\", () => {\n      this.props.onInit && this.props.onInit();\n\n      if (this.props.lazyLoad) {\n        let slidesToLoad = getOnDemandLazySlides(_objectSpread(_objectSpread({}, this.props), this.state));\n\n        if (slidesToLoad.length > 0) {\n          this.setState(prevState => ({\n            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n          }));\n\n          if (this.props.onLazyLoad) {\n            this.props.onLazyLoad(slidesToLoad);\n          }\n        }\n      }\n\n      let spec = _objectSpread({\n        listRef: this.list,\n        trackRef: this.track\n      }, this.props);\n\n      this.updateState(spec, true, () => {\n        this.adaptHeight();\n        this.props.autoplay && this.autoPlay(\"update\");\n      });\n\n      if (this.props.lazyLoad === \"progressive\") {\n        this.lazyLoadTimer = setInterval(this.progressiveLazyLoad, 1000);\n      }\n\n      this.ro = new ResizeObserver(() => {\n        if (this.state.animating) {\n          this.onWindowResized(false); // don't set trackStyle hence don't break animation\n\n          this.callbackTimers.push(setTimeout(() => this.onWindowResized(), this.props.speed));\n        } else {\n          this.onWindowResized();\n        }\n      });\n      this.ro.observe(this.list);\n      Array.prototype.forEach.call(document.querySelectorAll(\".slick-slide\"), slide => {\n        slide.onfocus = this.props.pauseOnFocus ? this.onSlideFocus : null;\n        slide.onblur = this.props.pauseOnFocus ? this.onSlideBlur : null;\n      });\n\n      if (window.addEventListener) {\n        window.addEventListener(\"resize\", this.onWindowResized);\n      } else {\n        window.attachEvent(\"onresize\", this.onWindowResized);\n      }\n    });\n\n    _defineProperty(this, \"componentWillUnmount\", () => {\n      if (this.animationEndCallback) {\n        clearTimeout(this.animationEndCallback);\n      }\n\n      if (this.lazyLoadTimer) {\n        clearInterval(this.lazyLoadTimer);\n      }\n\n      if (this.callbackTimers.length) {\n        this.callbackTimers.forEach(timer => clearTimeout(timer));\n        this.callbackTimers = [];\n      }\n\n      if (window.addEventListener) {\n        window.removeEventListener(\"resize\", this.onWindowResized);\n      } else {\n        window.detachEvent(\"onresize\", this.onWindowResized);\n      }\n\n      if (this.autoplayTimer) {\n        clearInterval(this.autoplayTimer);\n      }\n\n      this.ro.disconnect();\n    });\n\n    _defineProperty(this, \"componentDidUpdate\", prevProps => {\n      this.checkImagesLoad();\n      this.props.onReInit && this.props.onReInit();\n\n      if (this.props.lazyLoad) {\n        let slidesToLoad = getOnDemandLazySlides(_objectSpread(_objectSpread({}, this.props), this.state));\n\n        if (slidesToLoad.length > 0) {\n          this.setState(prevState => ({\n            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)\n          }));\n\n          if (this.props.onLazyLoad) {\n            this.props.onLazyLoad(slidesToLoad);\n          }\n        }\n      } // if (this.props.onLazyLoad) {\n      //   this.props.onLazyLoad([leftMostSlide])\n      // }\n\n\n      this.adaptHeight();\n\n      let spec = _objectSpread(_objectSpread({\n        listRef: this.list,\n        trackRef: this.track\n      }, this.props), this.state);\n\n      const setTrackStyle = this.didPropsChange(prevProps);\n      setTrackStyle && this.updateState(spec, setTrackStyle, () => {\n        if (this.state.currentSlide >= React.Children.count(this.props.children)) {\n          this.changeSlide({\n            message: \"index\",\n            index: React.Children.count(this.props.children) - this.props.slidesToShow,\n            currentSlide: this.state.currentSlide\n          });\n        }\n\n        if (this.props.autoplay) {\n          this.autoPlay(\"update\");\n        } else {\n          this.pause(\"paused\");\n        }\n      });\n    });\n\n    _defineProperty(this, \"onWindowResized\", setTrackStyle => {\n      if (this.debouncedResize) this.debouncedResize.cancel();\n      this.debouncedResize = debounce(() => this.resizeWindow(setTrackStyle), 50);\n      this.debouncedResize();\n    });\n\n    _defineProperty(this, \"resizeWindow\", (setTrackStyle = true) => {\n      const isTrackMounted = Boolean(this.track && this.track.node); // prevent warning: setting state on unmounted component (server side rendering)\n\n      if (!isTrackMounted) return;\n\n      let spec = _objectSpread(_objectSpread({\n        listRef: this.list,\n        trackRef: this.track\n      }, this.props), this.state);\n\n      this.updateState(spec, setTrackStyle, () => {\n        if (this.props.autoplay) this.autoPlay(\"update\");else this.pause(\"paused\");\n      }); // animating state should be cleared while resizing, otherwise autoplay stops working\n\n      this.setState({\n        animating: false\n      });\n      clearTimeout(this.animationEndCallback);\n      delete this.animationEndCallback;\n    });\n\n    _defineProperty(this, \"updateState\", (spec, setTrackStyle, callback) => {\n      let updatedState = initializedState(spec);\n      spec = _objectSpread(_objectSpread(_objectSpread({}, spec), updatedState), {}, {\n        slideIndex: updatedState.currentSlide\n      });\n      let targetLeft = getTrackLeft(spec);\n      spec = _objectSpread(_objectSpread({}, spec), {}, {\n        left: targetLeft\n      });\n      let trackStyle = getTrackCSS(spec);\n\n      if (setTrackStyle || React.Children.count(this.props.children) !== React.Children.count(spec.children)) {\n        updatedState[\"trackStyle\"] = trackStyle;\n      }\n\n      this.setState(updatedState, callback);\n    });\n\n    _defineProperty(this, \"ssrInit\", () => {\n      if (this.props.variableWidth) {\n        let trackWidth = 0,\n            trackLeft = 0;\n        let childrenWidths = [];\n        let preClones = getPreClones(_objectSpread(_objectSpread(_objectSpread({}, this.props), this.state), {}, {\n          slideCount: this.props.children.length\n        }));\n        let postClones = getPostClones(_objectSpread(_objectSpread(_objectSpread({}, this.props), this.state), {}, {\n          slideCount: this.props.children.length\n        }));\n        this.props.children.forEach(child => {\n          childrenWidths.push(child.props.style.width);\n          trackWidth += child.props.style.width;\n        });\n\n        for (let i = 0; i < preClones; i++) {\n          trackLeft += childrenWidths[childrenWidths.length - 1 - i];\n          trackWidth += childrenWidths[childrenWidths.length - 1 - i];\n        }\n\n        for (let i = 0; i < postClones; i++) {\n          trackWidth += childrenWidths[i];\n        }\n\n        for (let i = 0; i < this.state.currentSlide; i++) {\n          trackLeft += childrenWidths[i];\n        }\n\n        let trackStyle = {\n          width: trackWidth + \"px\",\n          left: -trackLeft + \"px\"\n        };\n\n        if (this.props.centerMode) {\n          let currentWidth = `${childrenWidths[this.state.currentSlide]}px`;\n          trackStyle.left = `calc(${trackStyle.left} + (100% - ${currentWidth}) / 2 ) `;\n        }\n\n        return {\n          trackStyle\n        };\n      }\n\n      let childrenCount = React.Children.count(this.props.children);\n\n      const spec = _objectSpread(_objectSpread(_objectSpread({}, this.props), this.state), {}, {\n        slideCount: childrenCount\n      });\n\n      let slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;\n      let trackWidth = 100 / this.props.slidesToShow * slideCount;\n      let slideWidth = 100 / slideCount;\n      let trackLeft = -slideWidth * (getPreClones(spec) + this.state.currentSlide) * trackWidth / 100;\n\n      if (this.props.centerMode) {\n        trackLeft += (100 - slideWidth * trackWidth / 100) / 2;\n      }\n\n      let trackStyle = {\n        width: trackWidth + \"%\",\n        left: trackLeft + \"%\"\n      };\n      return {\n        slideWidth: slideWidth + \"%\",\n        trackStyle: trackStyle\n      };\n    });\n\n    _defineProperty(this, \"checkImagesLoad\", () => {\n      let images = this.list.querySelectorAll(\".slick-slide img\");\n      let imagesCount = images.length,\n          loadedCount = 0;\n      Array.prototype.forEach.call(images, image => {\n        const handler = () => ++loadedCount && loadedCount >= imagesCount && this.onWindowResized();\n\n        if (!image.onclick) {\n          image.onclick = () => image.parentNode.focus();\n        } else {\n          const prevClickHandler = image.onclick;\n\n          image.onclick = () => {\n            prevClickHandler();\n            image.parentNode.focus();\n          };\n        }\n\n        if (!image.onload) {\n          if (this.props.lazyLoad) {\n            image.onload = () => {\n              this.adaptHeight();\n              this.callbackTimers.push(setTimeout(this.onWindowResized, this.props.speed));\n            };\n          } else {\n            image.onload = handler;\n\n            image.onerror = () => {\n              handler();\n              this.props.onLazyLoadError && this.props.onLazyLoadError();\n            };\n          }\n        }\n      });\n    });\n\n    _defineProperty(this, \"progressiveLazyLoad\", () => {\n      let slidesToLoad = [];\n\n      const spec = _objectSpread(_objectSpread({}, this.props), this.state);\n\n      for (let index = this.state.currentSlide; index < this.state.slideCount + getPostClones(spec); index++) {\n        if (this.state.lazyLoadedList.indexOf(index) < 0) {\n          slidesToLoad.push(index);\n          break;\n        }\n      }\n\n      for (let index = this.state.currentSlide - 1; index >= -getPreClones(spec); index--) {\n        if (this.state.lazyLoadedList.indexOf(index) < 0) {\n          slidesToLoad.push(index);\n          break;\n        }\n      }\n\n      if (slidesToLoad.length > 0) {\n        this.setState(state => ({\n          lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)\n        }));\n\n        if (this.props.onLazyLoad) {\n          this.props.onLazyLoad(slidesToLoad);\n        }\n      } else {\n        if (this.lazyLoadTimer) {\n          clearInterval(this.lazyLoadTimer);\n          delete this.lazyLoadTimer;\n        }\n      }\n    });\n\n    _defineProperty(this, \"slideHandler\", (index, dontAnimate = false) => {\n      const {\n        asNavFor,\n        beforeChange,\n        onLazyLoad,\n        speed,\n        afterChange\n      } = this.props; // capture currentslide before state is updated\n\n      const currentSlide = this.state.currentSlide;\n      let {\n        state,\n        nextState\n      } = slideHandler(_objectSpread(_objectSpread(_objectSpread({\n        index\n      }, this.props), this.state), {}, {\n        trackRef: this.track,\n        useCSS: this.props.useCSS && !dontAnimate\n      }));\n      if (!state) return;\n      beforeChange && beforeChange(currentSlide, state.currentSlide);\n      let slidesToLoad = state.lazyLoadedList.filter(value => this.state.lazyLoadedList.indexOf(value) < 0);\n      onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);\n\n      if (!this.props.waitForAnimate && this.animationEndCallback) {\n        clearTimeout(this.animationEndCallback);\n        afterChange && afterChange(currentSlide);\n        delete this.animationEndCallback;\n      }\n\n      this.setState(state, () => {\n        // asNavForIndex check is to avoid recursive calls of slideHandler in waitForAnimate=false mode\n        if (asNavFor && this.asNavForIndex !== index) {\n          this.asNavForIndex = index;\n          asNavFor.innerSlider.slideHandler(index);\n        }\n\n        if (!nextState) return;\n        this.animationEndCallback = setTimeout(() => {\n          const {\n            animating\n          } = nextState,\n                firstBatch = _objectWithoutProperties(nextState, [\"animating\"]);\n\n          this.setState(firstBatch, () => {\n            this.callbackTimers.push(setTimeout(() => this.setState({\n              animating\n            }), 10));\n            afterChange && afterChange(state.currentSlide);\n            delete this.animationEndCallback;\n          });\n        }, speed);\n      });\n    });\n\n    _defineProperty(this, \"changeSlide\", (options, dontAnimate = false) => {\n      const spec = _objectSpread(_objectSpread({}, this.props), this.state);\n\n      let targetSlide = changeSlide(spec, options);\n      if (targetSlide !== 0 && !targetSlide) return;\n\n      if (dontAnimate === true) {\n        this.slideHandler(targetSlide, dontAnimate);\n      } else {\n        this.slideHandler(targetSlide);\n      }\n\n      this.props.autoplay && this.autoPlay(\"update\");\n\n      if (this.props.focusOnSelect) {\n        const nodes = this.list.querySelectorAll(\".slick-current\");\n        nodes[0] && nodes[0].focus();\n      }\n    });\n\n    _defineProperty(this, \"clickHandler\", e => {\n      if (this.clickable === false) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n\n      this.clickable = true;\n    });\n\n    _defineProperty(this, \"keyHandler\", e => {\n      let dir = keyHandler(e, this.props.accessibility, this.props.rtl);\n      dir !== \"\" && this.changeSlide({\n        message: dir\n      });\n    });\n\n    _defineProperty(this, \"selectHandler\", options => {\n      this.changeSlide(options);\n    });\n\n    _defineProperty(this, \"disableBodyScroll\", () => {\n      const preventDefault = e => {\n        e = e || window.event;\n        if (e.preventDefault) e.preventDefault();\n        e.returnValue = false;\n      };\n\n      window.ontouchmove = preventDefault;\n    });\n\n    _defineProperty(this, \"enableBodyScroll\", () => {\n      window.ontouchmove = null;\n    });\n\n    _defineProperty(this, \"swipeStart\", e => {\n      if (this.props.verticalSwiping) {\n        this.disableBodyScroll();\n      }\n\n      let state = swipeStart(e, this.props.swipe, this.props.draggable);\n      state !== \"\" && this.setState(state);\n    });\n\n    _defineProperty(this, \"swipeMove\", e => {\n      let state = swipeMove(e, _objectSpread(_objectSpread(_objectSpread({}, this.props), this.state), {}, {\n        trackRef: this.track,\n        listRef: this.list,\n        slideIndex: this.state.currentSlide\n      }));\n      if (!state) return;\n\n      if (state[\"swiping\"]) {\n        this.clickable = false;\n      }\n\n      this.setState(state);\n    });\n\n    _defineProperty(this, \"swipeEnd\", e => {\n      let state = swipeEnd(e, _objectSpread(_objectSpread(_objectSpread({}, this.props), this.state), {}, {\n        trackRef: this.track,\n        listRef: this.list,\n        slideIndex: this.state.currentSlide\n      }));\n      if (!state) return;\n      let triggerSlideHandler = state[\"triggerSlideHandler\"];\n      delete state[\"triggerSlideHandler\"];\n      this.setState(state);\n      if (triggerSlideHandler === undefined) return;\n      this.slideHandler(triggerSlideHandler);\n\n      if (this.props.verticalSwiping) {\n        this.enableBodyScroll();\n      }\n    });\n\n    _defineProperty(this, \"touchEnd\", e => {\n      this.swipeEnd(e);\n      this.clickable = true;\n    });\n\n    _defineProperty(this, \"slickPrev\", () => {\n      // this and fellow methods are wrapped in setTimeout\n      // to make sure initialize setState has happened before\n      // any of such methods are called\n      this.callbackTimers.push(setTimeout(() => this.changeSlide({\n        message: \"previous\"\n      }), 0));\n    });\n\n    _defineProperty(this, \"slickNext\", () => {\n      this.callbackTimers.push(setTimeout(() => this.changeSlide({\n        message: \"next\"\n      }), 0));\n    });\n\n    _defineProperty(this, \"slickGoTo\", (slide, dontAnimate = false) => {\n      slide = Number(slide);\n      if (isNaN(slide)) return \"\";\n      this.callbackTimers.push(setTimeout(() => this.changeSlide({\n        message: \"index\",\n        index: slide,\n        currentSlide: this.state.currentSlide\n      }, dontAnimate), 0));\n    });\n\n    _defineProperty(this, \"play\", () => {\n      var nextIndex;\n\n      if (this.props.rtl) {\n        nextIndex = this.state.currentSlide - this.props.slidesToScroll;\n      } else {\n        if (canGoNext(_objectSpread(_objectSpread({}, this.props), this.state))) {\n          nextIndex = this.state.currentSlide + this.props.slidesToScroll;\n        } else {\n          return false;\n        }\n      }\n\n      this.slideHandler(nextIndex);\n    });\n\n    _defineProperty(this, \"autoPlay\", playType => {\n      if (this.autoplayTimer) {\n        clearInterval(this.autoplayTimer);\n      }\n\n      const autoplaying = this.state.autoplaying;\n\n      if (playType === \"update\") {\n        if (autoplaying === \"hovered\" || autoplaying === \"focused\" || autoplaying === \"paused\") {\n          return;\n        }\n      } else if (playType === \"leave\") {\n        if (autoplaying === \"paused\" || autoplaying === \"focused\") {\n          return;\n        }\n      } else if (playType === \"blur\") {\n        if (autoplaying === \"paused\" || autoplaying === \"hovered\") {\n          return;\n        }\n      }\n\n      this.autoplayTimer = setInterval(this.play, this.props.autoplaySpeed + 50);\n      this.setState({\n        autoplaying: \"playing\"\n      });\n    });\n\n    _defineProperty(this, \"pause\", pauseType => {\n      if (this.autoplayTimer) {\n        clearInterval(this.autoplayTimer);\n        this.autoplayTimer = null;\n      }\n\n      const autoplaying = this.state.autoplaying;\n\n      if (pauseType === \"paused\") {\n        this.setState({\n          autoplaying: \"paused\"\n        });\n      } else if (pauseType === \"focused\") {\n        if (autoplaying === \"hovered\" || autoplaying === \"playing\") {\n          this.setState({\n            autoplaying: \"focused\"\n          });\n        }\n      } else {\n        // pauseType  is 'hovered'\n        if (autoplaying === \"playing\") {\n          this.setState({\n            autoplaying: \"hovered\"\n          });\n        }\n      }\n    });\n\n    _defineProperty(this, \"onDotsOver\", () => this.props.autoplay && this.pause(\"hovered\"));\n\n    _defineProperty(this, \"onDotsLeave\", () => this.props.autoplay && this.state.autoplaying === \"hovered\" && this.autoPlay(\"leave\"));\n\n    _defineProperty(this, \"onTrackOver\", () => this.props.autoplay && this.pause(\"hovered\"));\n\n    _defineProperty(this, \"onTrackLeave\", () => this.props.autoplay && this.state.autoplaying === \"hovered\" && this.autoPlay(\"leave\"));\n\n    _defineProperty(this, \"onSlideFocus\", () => this.props.autoplay && this.pause(\"focused\"));\n\n    _defineProperty(this, \"onSlideBlur\", () => this.props.autoplay && this.state.autoplaying === \"focused\" && this.autoPlay(\"blur\"));\n\n    _defineProperty(this, \"render\", () => {\n      var className = classnames(\"slick-slider\", \"carousel\", this.props.className, {\n        \"carousel-center\": this.props.centerMode,\n        \"slick-vertical\": this.props.vertical,\n        \"slick-initialized\": true\n      });\n\n      let spec = _objectSpread(_objectSpread({}, this.props), this.state);\n\n      let trackProps = extractObject(spec, [\"fade\", \"cssEase\", \"speed\", \"infinite\", \"centerMode\", \"focusOnSelect\", \"currentSlide\", \"lazyLoad\", \"lazyLoadedList\", \"rtl\", \"slideWidth\", \"slideHeight\", \"listHeight\", \"vertical\", \"slidesToShow\", \"slidesToScroll\", \"slideCount\", \"trackStyle\", \"variableWidth\", \"unslick\", \"centerPadding\", \"targetSlide\", \"useCSS\"]);\n      const {\n        pauseOnHover\n      } = this.props;\n      trackProps = _objectSpread(_objectSpread({}, trackProps), {}, {\n        onMouseEnter: pauseOnHover ? this.onTrackOver : null,\n        onMouseLeave: pauseOnHover ? this.onTrackLeave : null,\n        onMouseOver: pauseOnHover ? this.onTrackOver : null,\n        focusOnSelect: this.props.focusOnSelect && this.clickable ? this.selectHandler : null\n      });\n      var dots;\n\n      if (this.props.dots === true && this.state.slideCount >= this.props.slidesToShow) {\n        let dotProps = extractObject(spec, [\"dotsClass\", \"slideCount\", \"slidesToShow\", \"currentSlide\", \"slidesToScroll\", \"clickHandler\", \"children\", \"customPaging\", \"infinite\", \"appendDots\"]);\n        const {\n          pauseOnDotsHover\n        } = this.props;\n        dotProps = _objectSpread(_objectSpread({}, dotProps), {}, {\n          clickHandler: this.changeSlide,\n          onMouseEnter: pauseOnDotsHover ? this.onDotsLeave : null,\n          onMouseOver: pauseOnDotsHover ? this.onDotsOver : null,\n          onMouseLeave: pauseOnDotsHover ? this.onDotsLeave : null\n        });\n        dots = __jsx(Dots, dotProps);\n      }\n\n      var prevArrow, nextArrow;\n      let arrowProps = extractObject(spec, [\"infinite\", \"centerMode\", \"currentSlide\", \"slideCount\", \"slidesToShow\", \"prevArrow\", \"nextArrow\"]);\n      arrowProps.clickHandler = this.changeSlide;\n\n      if (this.props.arrows) {\n        prevArrow = __jsx(PrevArrow, arrowProps);\n        nextArrow = __jsx(NextArrow, arrowProps);\n      }\n\n      var verticalHeightStyle = null;\n\n      if (this.props.vertical) {\n        verticalHeightStyle = {\n          height: this.state.listHeight\n        };\n      }\n\n      var centerPaddingStyle = null;\n\n      if (this.props.vertical === false) {\n        if (this.props.centerMode === true) {\n          centerPaddingStyle = {\n            padding: \"0px \" + this.props.centerPadding\n          };\n        }\n      } else {\n        if (this.props.centerMode === true) {\n          centerPaddingStyle = {\n            padding: this.props.centerPadding + \" 0px\"\n          };\n        }\n      }\n\n      const listStyle = _objectSpread(_objectSpread({}, verticalHeightStyle), centerPaddingStyle);\n\n      const touchMove = this.props.touchMove;\n      let listProps = {\n        className: \"slick-list\",\n        style: listStyle,\n        onClick: this.clickHandler,\n        onMouseDown: touchMove ? this.swipeStart : null,\n        onMouseMove: this.state.dragging && touchMove ? this.swipeMove : null,\n        onMouseUp: touchMove ? this.swipeEnd : null,\n        onMouseLeave: this.state.dragging && touchMove ? this.swipeEnd : null,\n        onTouchStart: touchMove ? this.swipeStart : null,\n        onTouchMove: this.state.dragging && touchMove ? this.swipeMove : null,\n        onTouchEnd: touchMove ? this.touchEnd : null,\n        onTouchCancel: this.state.dragging && touchMove ? this.swipeEnd : null,\n        onKeyDown: this.props.accessibility ? this.keyHandler : null\n      };\n      let innerSliderProps = {\n        className: className,\n        dir: \"ltr\",\n        style: this.props.style\n      };\n\n      if (this.props.unslick) {\n        listProps = {\n          className: \"slick-list\"\n        };\n        innerSliderProps = {\n          className\n        };\n      }\n\n      return __jsx(\"div\", innerSliderProps, !this.props.unslick ? prevArrow : \"\", __jsx(\"div\", _extends({\n        ref: this.listRefHandler\n      }, listProps), __jsx(Track, _extends({\n        ref: this.trackRefHandler\n      }, trackProps), this.props.children)), !this.props.unslick ? nextArrow : \"\", !this.props.unslick ? dots : \"\");\n    });\n\n    this.list = null;\n    this.track = null;\n    this.state = _objectSpread(_objectSpread({}, initialState), {}, {\n      currentSlide: this.props.initialSlide,\n      slideCount: React.Children.count(this.props.children)\n    });\n    this.callbackTimers = [];\n    this.clickable = true;\n    this.debouncedResize = null;\n    const ssrState = this.ssrInit();\n    this.state = _objectSpread(_objectSpread({}, this.state), ssrState);\n  }\n\n  didPropsChange(prevProps) {\n    let setTrackStyle = false;\n\n    for (let key of Object.keys(this.props)) {\n      if (!prevProps.hasOwnProperty(key)) {\n        setTrackStyle = true;\n        break;\n      }\n\n      if (typeof prevProps[key] === \"object\" || typeof prevProps[key] === \"function\") {\n        continue;\n      }\n\n      if (prevProps[key] !== this.props[key]) {\n        setTrackStyle = true;\n        break;\n      }\n    }\n\n    return setTrackStyle || React.Children.count(this.props.children) !== React.Children.count(prevProps.children);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}